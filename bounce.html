<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>iPhone-Like Momentum Scroll</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0 }
    body, html { height: 100%; overflow: hidden }
    .photo-container {
      position: relative;
      width: 100%; height: 100vh;
      background: #111;
      overflow: hidden;
      touch-action: none;
      overscroll-behavior: none;
    }
    .photo-grid {
      position: absolute; top: 0; left: 0; right: 0;
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      grid-auto-rows: 120px;
      gap: 6px;
      will-change: transform;
    }
    .photo-grid img {
      width: 100%; height: 100%;
      object-fit: cover;
      border-radius: 4px;
      background: #222;
    }
  </style>
</head>
<body>
  <div id="photo-container" class="photo-container"></div>
  <script>
    function createPhotoGrid(container, photoUrls) {
      // build grid
      const grid = document.createElement('div');
      grid.className = 'photo-grid'; container.appendChild(grid);
      photoUrls.forEach(src => { const img = document.createElement('img'); img.src = src; grid.appendChild(img); });

      // state
      let posY = 0, velY = 0, animating = false, state = 'idle';
      let boundary = 0, minY = 0, maxY = 0;
      let lastInput = 'wheel'; // track last input type

      // tuning constants
      const LINE_HEIGHT       = 16;      // px per line unit (deltaMode=1)
      const MAX_DY            = 100;     // px range for accel mapping
      const MIN_ACCEL         = 0.1;     // min accel for small deltas
      const MAX_ACCEL         = 0.7;     // max accel for large deltas
      const FRICTION_TRACKPAD = 0.92;    // high friction for touch
      const FRICTION_WHEEL    = 0.96;    // slightly lower friction for wheel
      const MAX_OVERSHOOT     = 400;     // px bounce for wheel
      const TOUCH_OVERSHOOT   = 50;      // smaller bounce for touch
      const W_WHEEL           = 0.02;    // spring freq for wheel bounce
      const C_WHEEL           = 2 * W_WHEEL;  // critical damping wheel
      const W_TOUCH           = 0.005;   // slower spring freq touch
      const C_TOUCH           = 5 * W_TOUCH;  // overdamped touch (no jiggle)
      const V_STOP            = 0.2;     // stop velocity
      const P_STOP            = 0.5;     // snap threshold
      const MAX_FLING         = 100;     // clamp fling speed

      let currentFriction = FRICTION_WHEEL;

      function updateBounds() {
        const Hc = container.clientHeight, Hg = grid.scrollHeight;
        maxY = 0; minY = Math.min(Hc - Hg, 0);
      }
      updateBounds(); window.addEventListener('resize', updateBounds);

      function setY(y) { grid.style.transform = `translateY(${y.toFixed(2)}px)`; }
      function finishSnap(to) {
        grid.style.transition = 'transform 200ms ease-out'; posY = to; setY(posY);
        grid.addEventListener('transitionend', () => { grid.style.transition = ''; animating = false; state = 'idle'; }, { once: true });
      }

      function loop() {
        // choose spring/overshoot settings by input
        const isTouch = lastInput === 'touch';
        const overshootLimit = isTouch ? TOUCH_OVERSHOOT : MAX_OVERSHOOT;
        const W = isTouch ? W_TOUCH : W_WHEEL;
        const C = isTouch ? C_TOUCH : C_WHEEL;
        const K = W * W;

        if (state === 'scroll') {
          velY *= currentFriction;
          velY = Math.max(-MAX_FLING, Math.min(MAX_FLING, velY));
          posY += velY; setY(posY);
          // boundary?
          if (posY > maxY || posY < minY) {
            boundary = posY > maxY ? maxY : minY;
            // clamp overshoot
            const over = posY - boundary;
            if (Math.abs(over) > overshootLimit) posY = boundary + Math.sign(over) * overshootLimit;
            velY = 0;
            state = 'spring';
          } else if (Math.abs(velY) < V_STOP) {
            animating = false; state = 'idle'; return;
          }
        } else if (state === 'spring') {
          const over = posY - boundary;
          const a = -K * over - C * velY;
          velY += a; posY += velY; setY(posY);
          if (Math.abs(over) < P_STOP && Math.abs(velY) < V_STOP) {
            return finishSnap(boundary);
          }
        }
        requestAnimationFrame(loop);
      }

      function norm(v) { return Math.min(Math.abs(v), MAX_DY) / MAX_DY; }

      // wheel handler
      container.addEventListener('wheel', e => {
        e.preventDefault(); lastInput = 'wheel';
        const mult = e.deltaMode === 1 ? LINE_HEIGHT : e.deltaMode === 2 ? container.clientHeight : 1;
        const dy = e.deltaY * mult, t = norm(dy);
        // interrupt spring only on reverse
        if (state === 'spring') {
          const springDir = Math.sign(boundary - posY), wheelDir = Math.sign(-dy);
          if (wheelDir === springDir) return;
          animating = false; state = 'idle';
        }
        const accel = MIN_ACCEL + (MAX_ACCEL - MIN_ACCEL) * t;
        currentFriction = FRICTION_TRACKPAD + (FRICTION_WHEEL - FRICTION_TRACKPAD) * t;
        velY -= dy * accel; state = 'scroll';
        if (!animating) { animating = true; requestAnimationFrame(loop); }
      }, { passive: false });

      // pointer (touch) handlers
      let isDown = false, lastY = 0;
      container.addEventListener('pointerdown', e => { e.preventDefault(); isDown = true; lastY = e.clientY; animating = false; state = 'idle'; }, { passive: false });
      container.addEventListener('pointermove', e => {
        if (!isDown) return; e.preventDefault();
        const d = e.clientY - lastY; posY += d; setY(posY); velY = d; lastY = e.clientY;
      }, { passive: false });
      container.addEventListener('pointerup', e => {
        if (!isDown) return; isDown = false; lastInput = 'touch';
        currentFriction = FRICTION_TRACKPAD;
        state = 'scroll'; animating = true;
        requestAnimationFrame(loop);
      }, { passive: false });
    }

    // instantiate demo
    const photos = Array.from({ length: 600 }, () => `https://picsum.photos/seed/${Math.floor(Math.random() * 1e6)}/200/200`);
    createPhotoGrid(document.getElementById('photo-container'), photos);
  </script>
</body>
</html>
